#include <cstdio>
#include <cstring>
#include <cmath>
#include <string>
#include <iostream>
#include <iomanip>
#include <memory.h>
#include <queue>
#include <algorithm>
#include <vector>
#include <stack>
using namespace std;
#define rep(i, a, b) for(int i = (a); i <= (b); i++)
#define red(i, a, b) for(int i = (a); i >= (b); i--)
#define LD long double
#define ll long long
#define ull unsigned long long
#define abs ABS
#define sqr SQR
#define PII pair<int, int>
#define MP make_pair
#define PB push_back
#define FI first
#define SE second
#define v_itr vector<int>::iterator
template<typename tn> void read(tn& a) {
    tn x = 0, f = 1; char c = getchar();
    while(!isdigit(c)) {
        if (c == '-') f = -1;
        c = getchar();
    }
    while(isdigit(c)) x = x * 10 + c - '0', c = getchar();
    a = x * f;
}
template<typename tn> void cmax(tn& a, tn b) { if (b > a) a = b; }
template<typename tn> void cmin(tn& a, tn b) { if (b < a) a = b; }
template<typename tn> tn abs(tn a) { return a < 0 ? -a : a; }
template<typename tn> tn sqr(tn a) { return a * a; }

const int N = 210000;
vector<int> E[N], lst[N << 1];
vector<int> *incr[N], *decr[N], *tail = lst;
int fa[N], q[N], a[N], n, ans;

inline void BFS() {
	int l, r; q[l = r = 0] = 0;
	while(l <= r) {
		int x = q[l++];
		for(int i = 0; i < E[x].size(); ++i) {
			int v = E[x][i];
			if (v == fa[x]) continue;
			fa[v] = x; q[++r] = v; 
		}
	}
}
void Query_In_Root(vector<int> &a, vector<int> &b, int v) {
	int pos1 = lower_bound(a.begin(), a.end(), v) - a.begin();
	int pos2 = lower_bound(b.begin(), b.end(), -v) - b.begin();
	cmax(ans, pos1 + pos2 + 1);
}
void Query_No_Root(vector<int> *a, vector<int> *b) {
	if (a->size() < b->size()) swap(a, b);
	for(int i = 0; i < b->size(); i++) {
		int pos = lower_bound(a->begin(), a->end(), -(*b)[i]) - a->begin();
		cmax(ans, pos + i + 1);
	}
}
void Query_1(int x, int y, int z) {
	Query_In_Root(*incr[x], *decr[y], z);
	Query_In_Root(*incr[y], *decr[x], z);
	Query_No_Root(incr[x], decr[y]);
	Query_No_Root(incr[y], decr[x]);
}
void Merge_Vec_Vec(vector<int> *&a, vector<int> *&b) {
	if (a->size() < b->size()) swap(a, b);
	for(int i = 0; i < b->size(); i++)
		cmin((*a)[i], (*b)[i]);
}
void Merge_1(int x, int y) {
	Merge_Vec_Vec(incr[x], incr[y]);
	Merge_Vec_Vec(decr[x], decr[y]);
}
void Query_2(int x, int v) {
	int pos = lower_bound(incr[x]->begin(), incr[x]->end(), v) - incr[x]->begin();
	cmax(ans, pos + 1);
	pos = lower_bound(decr[x]->begin(), decr[x]->end(), -v) - decr[x]->begin();
	cmax(ans, pos + 1);
}
void Merge_Vec_Int(vector<int> &a, int v) {
	v_itr pos = lower_bound(a.begin(), a.end(), v);
	if (pos == a.end()) a.PB(v);
	else *pos = v;
}
void DP(int x) {
	int czgj = -1;
	for(int i = 0; i < E[x].size(); ++i) {
		if (E[x][i] == fa[x]) continue;
		int v = E[x][i];
		if (czgj == -1) czgj = v;
		else Query_1(czgj, v, a[x]), Merge_1(czgj, v);
	}
	if (czgj == -1) {
		incr[x] = tail++; decr[x] = tail++;
		incr[x]->PB(a[x]); decr[x]->PB(-a[x]);
	}else {
		incr[x] = incr[czgj]; decr[x] = decr[czgj];
		Query_2(x, a[x]);
		Merge_Vec_Int(*incr[x], a[x]);
		Merge_Vec_Int(*decr[x], -a[x]);
	}
}
int main() {
	while(scanf("%d", &n) != EOF) {
		rep(i, 0, n - 1) read(a[i]);
		rep(i, 1, n - 1) {
			int x, y; read(x); read(y);
			--x; --y;
			E[x].PB(y); E[y].PB(x);
		}
		BFS();
		red(i, n - 1, 0) DP(q[i]);
		printf("%d\n", ans > 0 ? ans : 1);
		rep(i, 0, n - 1) E[i].clear(), (*incr)[i].clear(), (*decr)[i].clear();
		rep(i, 0, n * 2 - 2) lst[i].clear();
		ans = 0;
		memset(fa, 0, sizeof(fa));
		memset(a, 0, sizeof(a));
		memset(q, 0, sizeof(q));
	}
	return 0;
}